
#[macro_use]
extern crate npy_derive;
extern crate npy;
extern crate byteorder;

use std::io::Read;
use std::io::{Cursor,Write};
use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian};
use npy::{DType,Seriazable};

#[derive(NpyData, Debug)]
struct Array {
    vec: Vector5,
}

#[derive(Debug)]
struct Vector5(Vec<i32>);

impl Seriazable for Vector5 {
    fn dtype() -> DType {
        DType { ty: "<i4", shape: vec![5] }
    }

    fn read(c: &mut Cursor<&[u8]>) -> std::io::Result<Self> {
        let mut ret = Vector5(vec![]);
        for _ in 0..5 {
            ret.0.push(c.read_i32::<LittleEndian>()?);
        }
        Ok(ret)
    }

    fn write<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        for i in 0..5 {
            writer.write_i32::<LittleEndian>(self.0[i])?
        }
        Ok(())
    }
}

// examples/vector.npy is generated by this Python code:
//
// import numpy as np
// a = np.array([([1,2,3,4,5],), ([6,7,8,9,10],)], dtype=[('vec', 'i4', (5,))])
// np.save('examples/vector.npy', a)

fn main() {
    let mut buf = vec![];
    std::fs::File::open("examples/vector.npy").unwrap()
        .read_to_end(&mut buf).unwrap();

    for arr in npy::from_bytes::<Array>(&buf).unwrap() {
        println!("{:?}", arr);
    }
}
