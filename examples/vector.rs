
#[macro_use]
extern crate npy_derive;
extern crate npy;
extern crate byteorder;

use std::io::{Read,Write};
use byteorder::{WriteBytesExt, LittleEndian};
use npy::{DType,Serializable};
use byteorder::ByteOrder;

use npy::NpyData;

#[derive(NpyRecord, Debug)]
struct Array {
    vec: Vector5,
}

#[derive(Debug)]
struct Vector5(Vec<i32>);

// Note that for a vector of 5 elements, an array [i32; 5] with `impl Serializable` provided by
// this crate can be used instead. This example merely illustrates a possible way to implement
// Serializable.
impl Serializable for Vector5 {
    fn dtype() -> DType {
        DType { ty: "<i4", shape: vec![5] }
    }

    fn n_bytes() -> usize { 5 * 4 }

    fn read(buf: &[u8]) -> Self {
        let mut ret = Vector5(vec![]);
        for _ in 0..5 {
            ret.0.push(LittleEndian::read_i32(buf));
        }
        ret
    }

    fn write<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        for i in 0..5 {
            writer.write_i32::<LittleEndian>(self.0[i])?
        }
        Ok(())
    }
}

// examples/vector.npy is generated by this Python code:
//
// import numpy as np
// a = np.array([([1,2,3,4,5],), ([6,7,8,9,10],)], dtype=[('vec', 'i4', (5,))])
// np.save('examples/vector.npy', a)

fn main() {
    let mut buf = vec![];
    std::fs::File::open("examples/vector.npy").unwrap()
        .read_to_end(&mut buf).unwrap();

    let data: NpyData<Array> = NpyData::from_bytes(&buf).unwrap();
    for arr in data.iter() {
        println!("{:?}", arr);
    }
}
